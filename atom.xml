<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dtshuaishuai</title>
  
  <subtitle>Shuaishuai space</subtitle>
  <link href="https://dtsyyds.github.io/atom.xml" rel="self"/>
  
  <link href="https://dtsyyds.github.io/"/>
  <updated>2023-10-05T09:19:14.545Z</updated>
  <id>https://dtsyyds.github.io/</id>
  
  <author>
    <name>Dtshuai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://dtsyyds.github.io/2023/10/05/C++%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"/>
    <id>https://dtsyyds.github.io/2023/10/05/C++%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/</id>
    <published>2023-10-05T08:35:23.135Z</published>
    <updated>2023-10-05T09:19:14.545Z</updated>
    
    <content type="html"><![CDATA[<h1 id="力扣刷题算法学习之旅"><a href="#力扣刷题算法学习之旅" class="headerlink" title="力扣刷题算法学习之旅"></a>力扣刷题算法学习之旅</h1><p><strong><em>sort(num.begin(), num.end())</em></strong></p><p>排序算法：冒泡、快速、插入、希尔、归并、选择、基数、桶</p><p><strong><em>sort(num.begin(), num.end())</em></strong>  类似于快速排序，时间复杂度nlog2(n)</p><p>当数据量较大时采用快速排序，分段递归；当数据量小于一值时，改用插入排序</p><p>头文件：<strong><em>#include\<algorithm></em></strong></p><p>参数：<strong><em>sort(num.begin(), num.end(), cmp)</em></strong>  </p><p><strong><em>num.begin():</em></strong>    第一个元素的指针       <strong><em>num.rbegin():</em></strong>    倒序的第一个元素的指针</p><p><strong><em>num.end():</em></strong>    最后一个元素的下一个指针      <strong><em>num.rend():</em></strong></p><p><strong><em>cmp:</em></strong>    排序准则（从小到大/从大到小）自定义排序</p><p>例：</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;using namesapce std;bool cmp(int x, int y)&#123;    return x%10&gt;y%10;&#125;int main()&#123;    sortnum.begin, num.end, cmp;&#125;</code></pre><p>功能：实现对数组中的数按个位的大小进行排序</p><p>例：</p><pre><code>#include&lt;iostream&gt;#include&lt;algorithm&gt;using namesapce std;bool cmp(Student x, Student y)&#123;    return x.score&gt;y.score;&#125;int main()&#123;    sortnum.begin, num.end, cmp;&#125;struct Student&#123;string student;int score;StudentStudentstring n, int s:namen, scores&#125;;</code></pre><p>功能：实现对结构体中的数按大小进行排序</p><p><strong><em>assign()将一个容器中元素全部复制到另一个容器</em></strong></p><p><strong><em>void assign(const_iterator first, const_iterator last)</em></strong>    将区间（first, last）z中的元素复制到当前的vector容器中</p><p><strong><em>void assign(size_type n, const T&amp;x=T());</em></strong>    赋n个元素的值都vector中，这个容器会清楚掉vector容器中以前的内容</p><p><strong><em>for(int a:b)从数组b中依次取出元素赋值给整形变量a,循环执行for中的语句</em></strong></p><pre><code>for(int temp1 :b)&#123;    cout≪temp1;&#125;</code></pre><p><strong><em>这两种形式等价</em></strong></p><pre><code>for(int *p=&amp;b0;p!=&amp;b.size;p++)&#123;    int  a=*p;    cout≪a;&#125;</code></pre><p><strong><em>动态规划：1.求解最优化问题；2.原问题可以用包括子问题的递归式来描述；3.最优子结构，原问题的最优解可以且必须由子问题的最优解得到；4.重叠子问题，子问题在求解过程中反复出现，导致大量重复计算，所以要用记忆化搜索解决</em></strong></p><p><strong><em>贪心算法：寻找最优解，将求解过程分成若干个步骤，每个步骤都应用贪心算法，选取当前状态下的最优选择。</em></strong></p><p><a href="https://zhuanlan.zhihu.com/p/53334049"><strong><em>https://zhuanlan.zhihu.com/p/53334049</em></strong></a></p><p><strong><em>只能是每一步的最优解并不一定是整体的最优解</em></strong></p><p><strong><em>变长数组：程序在运行时需要动态分配内存空间的数组。<br>实现变长数组：一堆数组 vector\<int> array(len) –声明变长数组</em></strong></p><p><strong><em>srand（）：srand((unsigined)time(NULL));防止随机数重复，使用系统时间来初始化</em></strong></p><p><strong><em>后续调用rand()，即可产生随机数</em></strong><br><strong><em>push_back()和 emplace_back()：vector容器在末尾添加一个新元素</em></strong></p><p><strong><em>哈希表：<img src="C++算法.001.png" alt=""></em></strong></p><p><strong><em>常见散列函数：线性定值法、保留余数法、平方取中法、折叠法</em></strong></p><p><strong><em>解决地址冲突方法：线性探测法、平方探测法、再散列法、伪随机数法、拉链法</em></strong></p><pre><code>#include&lt;unordered_map&gt;unorderedmap&lt;int, int&gt;map;</code></pre><p><strong><em>哈希表中常用函数：map.insert({0, 0})-插入元素；map.begin()-返回指向哈希表开始位置的迭代器；map.end()-返回指向哈希表结尾位置的下一个元素 的迭代器；cbegin()和cend()-面向不可变的哈希表；bool isEmpty = map.empty()-判断哈希表是否为空；size()-返回哈希表大小；erase()-删除某个位置或某两个位置之间的元素；map.at(key)-根据key查找哈希表中的元素；map.clear()-清空哈希表中的元素；map.find(key)-以key作为参数寻找哈希表中的元素；map.bucket(key)-以key寻找哈希表中该元素储存的bucket编号；哈希表的遍历；</em></strong></p><p><strong><em>isalnum()：判断一个字符是否是字母或十进制数字，若为字母或者数字，则返回True,否则返回False        #include\<cctype></em></strong></p><p><code> </code><strong><em>tolowr()：若参数为大写字母则将对应的小写字母返回      #include<ctype.h></em></strong></p><p><strong><em>双指针：若参数为大写字母则将对应的小写字母返回      #include<ctype.h></em></strong></p><p><strong><em>二分查找：若参数为大写字母则将对应的小写字母返回      #include<ctype.h></em></strong></p><pre><code>int BinarySearch(int*sorted, int len, int search)&#123;    int left=0,  right=len-1,  middle=0;        while(left≤right)&#123;            middle=(left+right)/2;            if(sorted(middle==search))                return middle;            else if(sorted(middle&gt;search))                right=middle-1;            else                left=middle+1;        &#125;    return -1;&#125;</code></pre><p><strong><em>动态规划：用来求解最优化问题；原问题可以用子问题的递归式来描述；原问题的最优解可以通过子问题的最优解得到。</em></strong></p><p><strong><em>Vector容器末尾添加一个元素：emplace_back()、push_back()</em></strong></p><p><strong><em>Memset()：按字节赋值数组中的元素</em></strong></p><p><strong><em>Auto：根据后面的值来推测前面的数据类型，简化变量初始化</em></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;力扣刷题算法学习之旅&quot;&gt;&lt;a href=&quot;#力扣刷题算法学习之旅&quot; class=&quot;headerlink&quot; title=&quot;力扣刷题算法学习之旅&quot;&gt;&lt;/a&gt;力扣刷题算法学习之旅&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;sort(num.begin(), num.end(</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://dtsyyds.github.io/2023/10/02/Licteed%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/"/>
    <id>https://dtsyyds.github.io/2023/10/02/Licteed%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/</id>
    <published>2023-10-02T08:22:11.584Z</published>
    <updated>2023-10-03T14:31:26.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Licteed-刷题日记"><a href="#Licteed-刷题日记" class="headerlink" title="Licteed 刷题日记"></a>Licteed 刷题日记</h1><h2 id="1-面试经典500系列"><a href="#1-面试经典500系列" class="headerlink" title="1. 面试经典500系列"></a>1. 面试经典500系列</h2><h3 id="1-1数组"><a href="#1-1数组" class="headerlink" title="1.1数组"></a>1.1数组</h3><h4 id="a-合并两个有序数组"><a href="#a-合并两个有序数组" class="headerlink" title="a. 合并两个有序数组"></a>a. 合并两个有序数组</h4><pre><code>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。示例 1：输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3输出：[1,2,2,3,5,6]解释：需要合并 [1,2,3] 和 [2,5,6] 。合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。示例 2：输入：nums1 = [1], m = 1, nums2 = [], n = 0输出：[1]解释：需要合并 [1] 和 [] 。合并结果是 [1] 。示例 3：输入：nums1 = [0], m = 0, nums2 = [1], n = 1输出：[1]解释：需要合并的数组是 [] 和 [1] 。合并结果是 [1] 。注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</code></pre><p>题解：使用双指针，对两个数组中的元素进行大小比较，将数字按序插入一个新数组即可。</p><pre><code>class Solution &#123;public:void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;    int p1 = m-1, p2 = n-1;    int tail = m+n-1;    int cur = 0;    while(p1 &gt;= 0||p2&gt;=0)    &#123;        if(p1==-1)            cur = nums2[p2--];        else if(p2 == -1)            cur = nums1[p1--];        else if(nums1[p1] &gt; nums2[p2])            cur = nums1[p1--];        else            cur = nums2[p2--];        nums1[tail--] = cur;    &#125;&#125;&#125;;</code></pre><h4 id="b-移除元素"><a href="#b-移除元素" class="headerlink" title="b.移除元素"></a>b.移除元素</h4><pre><code>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。说明:为什么返回数值是整数，但输出的答案是数组呢?请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。你可以想象内部操作如下:// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i = 0; i &lt; len; i++) &#123;    print(nums[i]);&#125;示例 1：输入：nums = [3,2,2,3], val = 3输出：2, nums = [2,2]解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。示例 2：输入：nums = [0,1,2,2,3,0,4,2], val = 2输出：5, nums = [0,1,4,0,3]解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</code></pre><p>题解：使用单指针遍历数组，寻找目标对象删除即可。</p><pre><code>class Solution &#123;public:       int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;    int n = nums.size();    int left = 0;    while(left&lt;n)    &#123;        if(nums[left]==val)        &#123;            nums[left]=nums[n-1];            n--;        &#125;        else         left++;    &#125;return left;&#125;&#125;;</code></pre><h4 id="c-删除有序数组中的重复项"><a href="#c-删除有序数组中的重复项" class="headerlink" title="c.删除有序数组中的重复项"></a>c.删除有序数组中的重复项</h4><pre><code>给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。返回 k 。判题标准:系统会用下面的代码来测试你的题解:int[] nums = [...]; // 输入数组int[] expectedNums = [...]; // 长度正确的期望答案int k = removeDuplicates(nums); // 调用assert k == expectedNums.length;for (int i = 0; i &lt; k; i++) &#123;assert nums[i] == expectedNums[i];&#125;如果所有断言都通过，那么您的题解将被 通过。示例 1：输入：nums = [1,1,2]输出：2, nums = [1,2,_]解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。示例 2：输入：nums = [0,0,1,1,1,2,2,3,3,4]输出：5, nums = [0,1,2,3,4]解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</code></pre><p>题解：只需要保证前一个元素与当前元素不重复，遍历原数组即可。</p><pre><code>class Solution &#123;public:int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;    int n = nums.size();    if(n ==0)        return 0;    int left = 0, right = 1;    while(right &lt; n)    &#123;        if(nums[right] != nums[right-1])        &#123;            nums[left]=nums[right];            left++;        &#125;        right++;    &#125;    return left;&#125;&#125;;</code></pre><h4 id="d-删除有序数组中的重复项Ⅱ"><a href="#d-删除有序数组中的重复项Ⅱ" class="headerlink" title="d.删除有序数组中的重复项Ⅱ"></a>d.删除有序数组中的重复项Ⅱ</h4><pre><code>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。说明：为什么返回数值是整数，但输出的答案是数组呢？请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。你可以想象内部操作如下:// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i = 0; i &lt; len; i++) &#123;    print(nums[i]);&#125;示例 1：输入：nums = [1,1,1,2,2,3]输出：5, nums = [1,1,2,2,3]解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3。 不需要考虑数组中超出新长度后面的元素。示例 2：输入：nums = [0,0,1,1,1,1,2,3,3]输出：7, nums = [0,0,1,1,2,3,3]解释：函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3。不需要考虑数组中超出新长度后面的元素。</code></pre><p>题解：对于定序的数组，相同数组必然连续，故使用双指针，遍历数组检查每一个元素是否应该被保存，用慢指针表示数组的长度</p><pre><code>class Solution &#123;public:int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;    int n = nums.size();    if(n &lt;= 2)        return n;    int left = 2, right = 2;    while(right &lt; n)    &#123;        if(nums[right] != nums[left-2])        &#123;            nums[left]=nums[right];            left++;        &#125;        right++;    &#125;    return left;&#125;&#125;;</code></pre><h3 id="1-2矩阵"><a href="#1-2矩阵" class="headerlink" title="1.2矩阵"></a>1.2矩阵</h3><h4 id="a-有效的数独"><a href="#a-有效的数独" class="headerlink" title="a. 有效的数独"></a>a. 有效的数独</h4><pre><code>请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。数字 1-9 在每一行只能出现一次。数字 1-9 在每一列只能出现一次。数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）注意：一个有效的数独（部分已被填充）不一定是可解的。只需要根据以上规则，验证已经填入的数字是否有效即可。空白格用 &#39;.&#39; 表示。示例 1：输入：board = [[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出：true示例 2：输入：board = [[&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出：false解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</code></pre><p>题解：一次遍历，建立行、列两个长度为9的一维数组，用来统计每行、每列中出现的数字情况；将整个数独表划分为9个小数独表，保证同一个数字在小数独表中只出现一次</p><pre><code>class Solution &#123;public:bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;    int rows[9][9];    int colls[9][9];    int cell[3][3][9];    memset(rows, 0, sizeof(rows));    memset(colls, 0, sizeof(colls));    memset(cell, 0, sizeof(cell));    for(int i = 0; i&lt; 9;i++)    &#123;        for(int j=0; j&lt;9; j++)        &#123;            char c  = board[i][j];            if(c != &#39;.&#39;)            &#123;                int index = c - &#39;0&#39; - 1;                rows[i][index]++;                colls[j][index]++;                cell[i/3][j/3][index]++;                if(rows[i][index]&gt; 1 || colls[j][index] &gt; 1 ||cell[i/3][j/3][index]&gt;1)                    return false;            &#125;        &#125;    &#125;    return true;&#125;&#125;;</code></pre><h4 id="b-螺旋矩阵"><a href="#b-螺旋矩阵" class="headerlink" title="b. 螺旋矩阵"></a>b. 螺旋矩阵</h4><pre><code>给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。示例 1：输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]输出：[1,2,3,6,9,8,7,4,5]、示例 2：输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]输出：[1,2,3,4,8,12,11,10,9,5,6,7]</code></pre><p>题解1：每次遍历之后改变边界</p><pre><code>class Solution &#123;public:vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;    vector&lt;int&gt; ans;    int u = 0;    int d  = matrix.size() - 1;    int l = 0;    int r = matrix[0].size() - 1;    while(true)    &#123;        for(int i = l;i &lt;= r; ++i)            ans.emplace_back(matrix[u][i]);        if(++u &gt; d)            break;        for(int i = u; i &lt;= d; i++)            ans.emplace_back(matrix[i][r]);        if(--r &lt; l)            break;        for(int i = r; i&gt;= l;i--)            ans.emplace_back(matrix[d][i]);        if(--d&lt;u)            break;        for(int i =d; i&gt;= u;i--)            ans.emplace_back(matrix[i][l]);        if(++l&gt;r)            break;    &#125;    return ans;&#125;&#125;;</code></pre><h4 id="c-旋转图像"><a href="#c-旋转图像" class="headerlink" title="c.旋转图像"></a>c.旋转图像</h4><pre><code>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。示例 1：输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]输出：[[7,4,1],[8,5,2],[9,6,3]]示例 2：输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</code></pre><p>题解1：通过对题目的分析，发现第一行的元素恰好对应最后一列，第n行的元素对应倒数第n列，故进行数组赋值即可</p><pre><code>class Solution &#123;public:void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;  int n = matrix.size();  auto matrix_new = matrix;  for(int i = 0; i&lt; n;i++)  &#123;    for(int j = 0; j&lt;n;j++)      matrix_new[j][i] = matrix[n-i-1][j];  &#125;  matrix = matrix_new;&#125;&#125;;</code></pre><p>题解2：水平翻转+对角线反转</p><pre><code>class Solution &#123;public:void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;  int n = matrix.size();  for(int i = 0; i&lt;n/2;i++)  &#123;    for(int j = 0;j&lt;n;j++)      swap(matrix[i][j], matrix[n-i-1][j]);  &#125;  for(int i = 0;i&lt;n;i++)  &#123;    for(int j = 0;j&lt;i;j++)      swap(matrix[i][j], matrix[j][i]);  &#125;&#125;&#125;;</code></pre><h4 id="d-矩阵置零"><a href="#d-矩阵置零" class="headerlink" title="d.矩阵置零"></a>d.矩阵置零</h4><pre><code>给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。示例 1：输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]输出：[[1,0,1],[0,0,0],[1,0,1]]示例 2：输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]</code></pre><p>题解：<strong>使用两个标记数组分别记录每一行和每一列是否有零出现，然后按照标记数组在对应位置置0即可</strong></p><pre><code>class Solution &#123;public:void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;  int n = matrix.size();  int m = matrix[0].size();  vector&lt;int&gt; row(n), col(m);  for(int i = 0; i&lt;n;i++)  &#123;    for(int j = 0;j&lt;m;j++)    &#123;      if(!matrix[i][j])        row[i] = col[j] = true;    &#125;  &#125;  for(int i = 0; i&lt; n;i++)  &#123;    for(int j = 0; j&lt;m;j++)    &#123;      if(row[i]||col[j])        matrix[i][j] = 0;    &#125;  &#125;&#125;&#125;;</code></pre><h3 id="1-3哈希表"><a href="#1-3哈希表" class="headerlink" title="1.3哈希表"></a>1.3哈希表</h3><h4 id="a-赎金信"><a href="#a-赎金信" class="headerlink" title="a. 赎金信"></a>a. 赎金信</h4><pre><code>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。如果可以，返回 true ；否则返回 false 。magazine 中的每个字符只能在 ransomNote 中使用一次。示例 1：输入：ransomNote = &quot;a&quot;, magazine = &quot;b&quot;输出：false示例 2：输入：ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot;输出：false示例 3：输入：ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;输出：true</code></pre><p>题解：使用哈希表统计出现字符的个数，与需要使用的相减，判断数组是否满足条件</p><pre><code>class Solution &#123;public:bool canConstruct(string ransomNote, string magazine) &#123;  if(ransomNote.size() &gt; magazine.size())    return false;  vector&lt;int&gt; cnt(26);  for(auto &amp; c:magazine)    cnt[c-&#39;a&#39;]++;  for(auto &amp; c:ransomNote)  &#123;    cnt[c-&#39;a&#39;]--;    if(cnt[c-&#39;a&#39;] &lt; 0)      return false;  &#125;  return true;&#125;&#125;;</code></pre><h4 id="b-同构字符串"><a href="#b-同构字符串" class="headerlink" title="b.同构字符串"></a>b.同构字符串</h4><pre><code>给定两个字符串 s 和 t ，判断它们是否是同构的。如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。示例 1:输入：s = &quot;egg&quot;, t = &quot;add&quot;输出：true示例 2：输入：s = &quot;foo&quot;, t = &quot;bar&quot;输出：false示例 3：输入：s = &quot;paper&quot;, t = &quot;title&quot;输出：true</code></pre><p>题解：维护两张哈希表，</p><pre><code>class Solution &#123;public:bool canConstruct(string ransomNote, string magazine) &#123;  if(ransomNote.size() &gt; magazine.size())    return false;  vector&lt;int&gt; cnt(26);  for(auto &amp; c:magazine)    cnt[c-&#39;a&#39;]++;  for(auto &amp; c:ransomNote)  &#123;    cnt[c-&#39;a&#39;]--;    if(cnt[c-&#39;a&#39;] &lt; 0)      return false;  &#125;  return true;&#125;&#125;;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Licteed-刷题日记&quot;&gt;&lt;a href=&quot;#Licteed-刷题日记&quot; class=&quot;headerlink&quot; title=&quot;Licteed 刷题日记&quot;&gt;&lt;/a&gt;Licteed 刷题日记&lt;/h1&gt;&lt;h2 id=&quot;1-面试经典500系列&quot;&gt;&lt;a href=&quot;#1-</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://dtsyyds.github.io/2023/05/10/QT%E5%AD%A6%E4%B9%A0/"/>
    <id>https://dtsyyds.github.io/2023/05/10/QT%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-05-10T15:37:23.306Z</published>
    <updated>2023-05-10T15:35:51.178Z</updated>
    
    <content type="html"><![CDATA[<h1 id="QT开发上位机的学习及制作"><a href="#QT开发上位机的学习及制作" class="headerlink" title="QT开发上位机的学习及制作"></a>QT开发上位机的学习及制作</h1><h2 id="标签（空格分隔）：-QT-上位机"><a href="#标签（空格分隔）：-QT-上位机" class="headerlink" title="标签（空格分隔）： QT 上位机"></a>标签（空格分隔）： QT 上位机</h2><p><strong>QT的优点：</strong></p><ul><li>支持跨平台可拓展性高</li><li>接口简单，容易上手</li><li>简化内存回收机制<br><strong>QT的注意事项：</strong></li><li>类名：首字母大写，单词和单词之间首字母大写</li><li>函数名、变量名称、首字母小写；单词和单词之间首字母大写</li><li>快捷键：</li><li>ctrl + / 注释</li><li>ctrl + r 运行</li><li>ctrl + b 编译</li><li>ctrl + f 查找</li><li>ctrl + i 自动对齐</li><li>F1 帮助文档</li><li>F4 同名的.cpp和.h切换<br><strong>QT的按钮</strong><br><strong><em>1.QWidget</em></strong><br>按钮常用API<ol><li>show() 以顶层方式弹出窗口控件</li><li>setParent() 选择依赖方式</li><li>setText() 设置文本</li><li>resize() 重置窗口大小</li><li>move() 移动</li><li>setWindowTitle() 设置窗口大小</li><li>setFixedSize() 设置固定窗口大小<br><strong>QT的对象树</strong></li><li>当创建的对象在堆区的时候，如果指定的动作是QObject派生下来的类或子类</li><li>派生下来的类，可以不需要管理释放操作，而是将对象放入对象树<br><strong>QT的窗口坐标系</strong><br>默认笛卡尔坐标系【左上角为（0， 0）】<br><strong>QT的信号和槽</strong></li></ol></li><li>connect（信号的发送者，信号的具体信息，信号的接收者，信号的处理[槽]）<br> 信号槽的优点：松散耦合<br> 信号关键字： Signals<pre><code> chlicked(bool) 点击 pressed() 按下 released() 释放 toggled(bool) 切换状态</code></pre> 槽的关键字： Slots</li><li>自定义信号和槽位函数<br> 自定义信号：写在类的signals下，返回值为void，可以有参数，支持重载，不需要实现<br> 自定义槽函数：public slots[公共的槽函数],在全局函数或Public都行，返回值为void，需要声明，需要实现，可以有参数，支持重载<br> 用connect()连接信号和槽<br> emit触发信号<br> 信号和槽重载，用函数指针明确指向函数地址<br> QString转char<em>使用.toUtf8().data()<br> 信号和槽连接（触发信号后才能触发槽）<br> 信号和信号连接<br> 断开信号 disconnect<br>**</em>2.MainWindow<em>*</em></li><li>菜单栏QMenuBar<h1 id="菜单栏最多只能有一个"><a href="#菜单栏最多只能有一个" class="headerlink" title="菜单栏最多只能有一个"></a>菜单栏最多只能有一个</h1><code>QMenuBar *bar = menuBar(); setMenuBar(bar);QMenu *fileMenu = bar-&gt;addMenu(&quot;文件&quot;);QAction * newAction = filrMenu-&gt;addAction(&quot;新建&quot;);fileMenu -&gt;addSeparator();</code><ul><li>工具栏 QToolBar    <h1 id="工具栏可以有多个"><a href="#工具栏可以有多个" class="headerlink" title="工具栏可以有多个"></a>工具栏可以有多个</h1><code>QToolBar *toolbar = new QToolBar(this); addToolBar(toolBar);addToolBar(Qt::BottomToolBarArea, toolBar);toolBar -&gt; setFloatable(false);toolBar -&gt; setMovable(false);toolBar -&gt; addAction(QAction);toolBar -&gt; addWidget(QPushButton);</code></li><li>状态栏 QStatusBar    <h1 id="状态栏最多只能有一个"><a href="#状态栏最多只能有一个" class="headerlink" title="状态栏最多只能有一个"></a>状态栏最多只能有一个</h1><code>QStatusBar *stbar = statusBar(); setStatusBar(stBar);QLabel *label = new QLabel(&quot;左侧提示的信息&quot;, this);stBar -&gt; addWidget(label);stBar -&gt; addPermanentWidget(label1);</code></li><li>铆接部件 QDockWidget    <h1 id="铆接不见可以有多个"><a href="#铆接不见可以有多个" class="headerlink" title="铆接不见可以有多个"></a>铆接不见可以有多个</h1><code>QDockWidget * dockWidget = new QDockWidget(&quot;浮动&quot;, this);addDockWidget(Qt::BottomDockWidgetArea, dockWidget);dockWidget -&gt; setAllowedAreas(Qt::TopDockWidgetArea | Qt::BottomDockWidgetArea);</code></li><li>中心部件   <h1 id="中心内容也只能有一个"><a href="#中心内容也只能有一个" class="headerlink" title="中心内容也只能有一个"></a>中心内容也只能有一个</h1><code>QTextEdit * edit = new QTextEdit(this);setCentralWidget(edit);</code></li><li>资源文件   <ol><li>将图片文件文件夹拷贝到项目下</li><li>右键项目 -&gt; 添加新文件 -&gt; Qt -&gt; Qt recourse File</li><li>res 生成 res.qrc</li><li>右键rea.qrc -&gt; oprn in editor 编辑资源</li><li>添加前缀添加文件</li><li>使用” + 前缀名 + 文件名”</li></ol></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;QT开发上位机的学习及制作&quot;&gt;&lt;a href=&quot;#QT开发上位机的学习及制作&quot; class=&quot;headerlink&quot; title=&quot;QT开发上位机的学习及制作&quot;&gt;&lt;/a&gt;QT开发上位机的学习及制作&lt;/h1&gt;&lt;h2 id=&quot;标签（空格分隔）：-QT-上位机&quot;&gt;&lt;a </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://dtsyyds.github.io/2023/05/09/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>https://dtsyyds.github.io/2023/05/09/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</id>
    <published>2023-05-09T06:13:12.316Z</published>
    <updated>2023-05-09T14:28:50.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo-Github-创建博客"><a href="#Hexo-Github-创建博客" class="headerlink" title="Hexo + Github 创建博客"></a>Hexo + Github 创建博客</h1><p>标签（空格分隔）： hexo Github 避坑</p><hr><p><em>网上找到的搭建博客的教程良莠不齐，基本内容都大同小异，对于某些莫名出现的问题又没有合理的指导，小编在搭建的过程中也是颇为头疼，毕竟白天课业繁重，还在参加比赛，所以只能晚上赶班搭建，由于本博客是小编第一次尝试编写，所以可能会显得很啰嗦，有基础的伙伴可以跳过简读，适用于纯新手教学。<br>在此输入正文</em></p><p>本博客基于<a href="https://hexo.io/zh-cn/">Hexo</a>(高效的静态网站生成框架），它是基于<strong>Node.js</strong>,帮助我们快速便捷欸对搭建博客。下面就来介绍如何从零开始搭建自己的博客空间：</p><ul><li>安装Git<br>Git官网下载<a href="https://git-scm.com/downloads">Git</a><br><img src="https://pic1.zhimg.com/v2-4a869f07e53c834fc2b712661557f518_r.jpg" alt="此处输入图片的描述"><br>Git官网自动之别到了我使用的操作系统，点击“Download for windows”或者“Windows”即可到Git版本页面。<br>然后根据电脑的操作位数64（32）bit 安装对应的下载包。<br>双击下载成功的安装包，进入许可声明界面<br><img src="https://pic2.zhimg.com/80/v2-da23dc0a1c999f26e99150d9f3ab4fe5_720w.webp" alt="此处输入图片的描述"><br>点击 <strong>”next“</strong>进入下图界面<br><img src="https://pic2.zhimg.com/80/v2-c45a083142549072c4d3ab0db626503d_720w.webp" alt="此处输入图片的描述"><br>在这里选择git在你电脑上的安装路径，选择完成后，点击<strong>”next”</strong>进入选择组件界面<br><img src="https://pic3.zhimg.com/80/v2-aaaa44474c3317d8fc257200b23e8672_720w.webp" alt="此处输入图片的描述"><br>建议直接服从默认勾选，根据自己的需求选择后，点击<strong>”next”</strong>进入下一界面<br><img src="https://pic4.zhimg.com/80/v2-6316c3b62e7bb10360642854ab756d9f_720w.webp" alt="此处输入图片的描述"><br>这个界面是创建开始菜单中的名称，不需要修改，直接点击<strong>”next”</strong>进入下一界面<br><img src="https://pic3.zhimg.com/80/v2-d68f6fd56b6ff358a83bc9bb7346993e_720w.webp" alt="此处输入图片的描述"><br>这个界面是选择Git文件默认的编辑器，建议默认，点击<strong>”next”</strong>进入下一界面<br><img src="https://pic2.zhimg.com/80/v2-9ef958b0e9056cc7852616c7ea7fc1e5_720w.webp" alt="此处输入图片的描述"><br>这个页面是设置新存储库中初始分支的名称，默认是<strong>“master”</strong>，如果想修改分支名称，点击第二个选项，在“main”的位置修改即可，这里我选择默认的名称，点击<strong>”next”</strong>进入下一界面<br><img src="https://pic4.zhimg.com/80/v2-3ce1e46ed8c890996045630b090c409f_720w.webp" alt="此处输入图片的描述"><br>第一种配置是<strong>”仅从Git bash使用Git“</strong>，你只能从Git Bash 命令行工具，不能通过第三方软件使用。<br>第二种配置是<strong>”从命令行以及第三方软件进行Git”</strong>,它仅向PATH添加最小的Git安装包。<br>第三种配置是<strong>“从命令提示符使用Git和可选的Unix工具”</strong>，它将覆盖Windows工具，只有在了解其含义后才建议使用此选项。<br>推荐默认配置，点击<strong>”next”</strong>进入下一界面<br><img src="https://pic4.zhimg.com/80/v2-24bfe3f1a43e0c406afbbe4b9afe6c6f_720w.webp" alt="此处输入图片的描述"><br>选择SSH可执行文件，点击<strong>”next”</strong>进入下一界面<br><img src="https://pic2.zhimg.com/80/v2-b71fc99c8f6fa5958ddc54dfa1d1f945_720w.webp" alt="此处输入图片的描述"><br>第一个选项是<strong>“使用OpenSSL库”</strong>,服务器证书将使用ca-bundle.crt文件进行验证，这也是我们常用的配置。<br>第二个选项是<strong>“使用本地Window安全通道库”</strong>。服务器证书将使用Windows证书存储验证。此选项还允许您使用公司的内部根CA证书。<br>推荐默认配置，点击<strong>”next”</strong>进入下一界面<br><img src="https://pic2.zhimg.com/80/v2-82cfd01d91dd5ab2b73edffdbe5e1449_720w.webp" alt="此处输入图片的描述"><br>第一个选项是<strong>“签出Windows风格，提交Unix风格的行尾”</strong>。签出文本文件时，Git会将LF转换为CRLF。提交文本文件时，CRLF将转换为LF。对于跨平台项目，这是Windows上的推荐设置(“ core.autocrlf”设置为“ true”)<br>第二个选项是<strong>“按原样签出，提交Unix样式的行尾”</strong>。签出文本文件时，Git不会执行任何转换。 提交文本文件时，CRLF将转换为LF。对于跨平台项目，这是Unix上的建议设置(“ core.autocrlf”设置为“ input”)<br>第三种选项是<strong>“按原样签出，按原样提交”</strong>。当签出或提交文本文件时，Git不会执行任何转换。不建议跨平台项目选择此选项(“core.autocrlf”设置为“ false”)<br>推荐默认配置，点击<strong>”next”</strong>进入下一界面<br><img src="https://pic3.zhimg.com/80/v2-2d8ba89d06bb4b0f3ef65f9c217a7b56_720w.webp" alt="此处输入图片的描述"><br>第一个选项是<strong>“使用MinTTY(MSYS2的默认终端)”</strong>。Git Bash将使用MinTTY作为终端模拟器，该模拟器具有可调整大小的窗口，非矩形选择和Unicode字体。Windows控制台程序(例如交互式Python)必须通过“ winpty”启动才能在MinTTY中运行。<br>第二个选项是<strong>“使用Windows的默认控制台窗口”</strong>。Git将使用Windows的默认控制台窗口(“cmd.exe”)，该窗口可以与Win32控制台程序(如交互式Python或node.js)一起使用，但默认的回滚非常有限，需要配置为使用unicode字体以正确显示非ASCII字符，并且在Windows 10之前，其窗口不能自由调整大小，并且只允许矩形文本选择。<br>推荐默认配置，点击<strong>”next”</strong>进入下一界面<br><img src="https://pic3.zhimg.com/80/v2-007c0c4e274c91c7adab49146aeab75a_720w.webp" alt="此处输入图片的描述"><br>第一个选项：默认值(快进或合并)<br>这是“gitpull”的标准行为：尽可能将当前分支快速转发到获取的分支，否则创建合并提交<br>第二个选项：复位<br>将当前分支复位到获取的分支上。如果没有要重新设置基础的本地提交，这相当于快进。<br>第三个选项：只有快进<br>快进到获取的分支。如果不能获取，则失败。<br>推荐默认配置，点击<strong>”next”</strong>进入下一界面<br><img src="https://pic4.zhimg.com/80/v2-6e8dd4ef3548ad1032798043ed3b440f_720w.webp" alt="此处输入图片的描述"><br>配置凭证管理器<br>第一个选择项：<strong>Git凭证管理器</strong><br>第一个选择项：<strong>无，不要使用凭证管理器</strong><br>推荐默认配置，点击<strong>”next”</strong>进入下一界面<br><img src="https://pic1.zhimg.com/80/v2-816683c944fb69ebeaabbf173e8ae0b4_720w.webp" alt="此处输入图片的描述"><br>第一个选项：<strong>“启用文件系统缓存”</strong>。文件系统数据将被批量读取并缓存在内存中用于某些操作(“core.fscache”设置为“true”)。 这提供了显著的性能提升。<br>第二个选项：<strong>“启用符号链接”</strong>。启用符号链接(需要SeCreateSymbolicLink权限)。请注意，现有存储库不受此设置的影响<br>推荐默认配置，点击<strong>”next”</strong>进入下一界面<br><img src="https://pic2.zhimg.com/80/v2-1987dbd05c2a0e5e9b75e7d8c8856791_720w.webp" alt="此处输入图片的描述"><br>第一个选项：<strong>启用对伪控制台的实验性支持</strong>。<br>(新增!)这允许在git bash窗口中运行Node或Python之类的本机控制台程序，而无需使用winpty，但它仍然存在已知的bug。<br>第二个选项：<strong>启用实验性内置文件系统监视器</strong><br>(新增!)自动运行内置的文件系统监视程序，以加速包含许多文件的工作树中的常见操作，如“git status”、“git add”、“git commit”等。<br>大家可以根据需要自己选择，我这里都选上了，点击<strong>”install“</strong>开始安装。如上便是Git的安装配置操作。</li><li><p>安装nodejs<br><a href="https://nodejs.org/zh-cn/download">nodejs下载</a><br>参照Git的系统选择，选择对应的版本，可以不用最新版本的哈<br>双击下载后的安装包，点击”run”,一路”next”,火花带闪电，可以修改一下自己的存放路径。<br>检验PATH变量是否配置Node.js<br>win + R   在弹出的命令框输入cmd，键入</p><p> node -v<br>便可得到安装的node版本</p></li><li><p>安装Hexo<br>先创建一个文件夹MyBlog，用来存放自己的博客文件，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）,最好以管理员身份运行终端。原因是啥咱也不知道，咱也没问到，反正就是会出意想不到的情况。<br>定位到该目录下，输入<code>npm install -g hexo-cli</code>即可安装Hexo,有部分警告无视即可。<br>安装完输入<code>hexo -v</code>验证是否安装成功。<br>接下来就是初始化hexo,即进入主题根目录，输入<code>hexo init</code>初始化文件夹，然后输入<code>npm install</code>安装必备的组件，新建完成后，指定文件夹Hexo目录下有：</p></li><li><p>node_modules:依赖包</p></li><li>public：存放生成的页面</li><li>scaffolds:生成文章的一些模板</li><li>source:存放文章</li><li>themes:主题</li><li>_config.yml：博客的配置文件<br>这样本地的网站就配置成功了，键入<code>hexo g</code>生成静态网页，然后键入<code>hexo s</code>打开本地服务器，点击链接，便可在浏览器看到如下界面<br><img src="https://img-blog.csdnimg.cn/ba1f6eb9534f4cc2822ec5f15fae5d5d.png" alt="此处输入图片的描述"><br>按<code>ctrl+c</code>关闭本地服务器。<br>4.注册Github账号创建个人仓库<br>接下来就去注册一个github账号，用来存放我们的网站。大多数小伙伴应该都有了吧，作为一个合格的程序猿（媛）还是要有一个的。<br>要创建一个和你用户名相同的仓库，后面加.[<a href="http://github.io，只有这样，将来要部署到GitHub">http://github.io，只有这样，将来要部署到GitHub</a> page的时候，才会被识别，也就是<a href="http://xxxx.github.io，其中xxx就是你注册GitHub的用户名。例如我的：http://Dtsyyds.github.io">http://xxxx.github.io，其中xxx就是你注册GitHub的用户名。例如我的：http://Dtsyyds.github.io</a></li></ul><p>5.生成SSH添加到Github<br>在你所创建的博客文件夹右键打开git Bash(cmd指令也可以），然后输入以下命令：</p><pre><code>git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremali&quot;</code></pre><p>这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户,例如</p><pre><code>git config --global user.name &quot;Dtsyyds&quot;git config --global user.email &quot;1640028011@qq.com&quot;</code></pre><p>然后创建SSH，一路回车<br>这个时候它会告诉你已经生成了.ssh文件，根据终端提示的路径找到对应文件用记事本打开，全部复制。<br>打开<a href="https://github.com/Dtsyyds/Dtsyyds.github.io">Github</a>,在头像下面点击settings,再点击SSH and GPG keys，新建一个SSH，名字随便取一个你中意的，下一项默认，在key里面输入你的id_rsa.pub里复制的东西。<br>在<code>git bash</code>输入<code>ssh -T git@github.com</code>,如果弹出你的用户名即为成功，后面的does not provide shell access不用在意。<br>6.将hexo部署到GitHub<br>打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客配置相关的各种信息。</p><pre><code>deploy:</code></pre><p>  type: git<br>  repository: <a href="https://github.com/dtsyyds/Dtsyys.github.io.git">https://github.com/dtsyyds/Dtsyys.github.io.git</a><br>  branch: master</p><p>repository修改为你自己的github项目地址即可就是部署时，告诉工具，将生成网页通过git方式上传到你对应的链接仓库中这个时候需要先安装deploy-git，也就是部署的命令,这样你才能用命令部署到GitHub。<br>在根目录下键入<code>npm install hexo-deployer-git --save</code>(如果有报错，就用管理员权限执行），如果报错显示unable to acess …那就先执行<br><code>git config --global --unset http.proxygit config --global --unset https.proxy</code>取消代理，<br>然后</p><pre><code>hexo ghexo dhexo s</code></pre><p>过一会，可能十分钟，也可能半个小时，你就可以在   <a href="http://yourname.github.io">http://yourname.github.io</a> 看到自己的博客网站了。<br>7.写文章，发布文章<br>首先在博客根目录下右键打开git bash，安装一个扩展npm i hexo-deployer-git。<br>然后输入hexo new post “我的第一篇博客”，新建一篇文章。<br>然后打开D:\blog\source_posts的目录，可以发现下面多了一个文件夹和一个.md文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。<br>你可以会直接在vscode里面编写markdown文件，可以实时预览，也可以用用其他编辑md文件的软件的工具编写。编写完markdown文件后，根目录下输入hexo g生成静态网页，然后输入hexo s可以本地预览效果，最后输入hexo d上传到github上。这时打开你的github.io主页就能看到发布的文章啦。到这儿基本上就完成了，已经完整搭建起一个比较简陋的个人博客了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hexo-Github-创建博客&quot;&gt;&lt;a href=&quot;#Hexo-Github-创建博客&quot; class=&quot;headerlink&quot; title=&quot;Hexo + Github 创建博客&quot;&gt;&lt;/a&gt;Hexo + Github 创建博客&lt;/h1&gt;&lt;p&gt;标签（空格分隔）： </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://dtsyyds.github.io/2023/05/08/hello-world/"/>
    <id>https://dtsyyds.github.io/2023/05/08/hello-world/</id>
    <published>2023-05-08T15:00:50.819Z</published>
    <updated>2023-05-08T14:12:34.925Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo new "My New Post"</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-lang-bash"><code class="language-lang-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
